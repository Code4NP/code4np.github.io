[
  {
    "objectID": "posts/series_reproducibility/index.html",
    "href": "posts/series_reproducibility/index.html",
    "title": "Introduction to reproducible computing",
    "section": "",
    "text": "Components\nData handling - Raw - What’s a Symlink? - Intermediate - Final\nLanguage-agnostics version dependency management - Docker - Conda\nLanguage-specific version dependency management - Python - R"
  },
  {
    "objectID": "posts/intro_to_cheminformatics/index.html",
    "href": "posts/intro_to_cheminformatics/index.html",
    "title": "Introduction to Mass Spectrometry Analysis in R",
    "section": "",
    "text": "There’s a ton of ways to represent a molecule in a way that computer can understand. Some of these are easier for a human to read than others, and most (all?) have pros, cons, limitations that must be considered. (Values not checked, pulled from PubChem) SMILES = CC(=O)OC1=CC=CC=C1C(=O)O INCHI = InChI=1S/C9H8O4/c1-6(10)13-8-5-3-2-4-7(8)9(11)12/h2-5H,1H3,(H,11,12) INCHI-KEY =BSYNRYMUTXBXSQ-UHFFFAOYSA-N MOL: Encode atomic coordinates. SDF: Single file that contains one or more molecules in MOL format plus some additional info. Can contain more than one chemical entity in single entry.\nThe SDF file (also contains MOL format) is 157 lines long, so I won’t include it in this post, but you can view it (here)[https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/CID/2244/record/SDF?record_type=2d&response_type=display]\n\nAdditional Resources\nI recently came across a great source of information/tutorials for cheminformatics by the (Volkamer Lab)[https://volkamerlab.org/].https://github.com/volkamerlab/teachopencadd/\nTo jump right into a listing of their tutorials: https://projects.volkamerlab.org/teachopencadd/all_talktorials.html\nhttps://academic.oup.com/nar/article/50/W1/W753/6582172?login=false"
  },
  {
    "objectID": "posts/intro_to_mass_spec_in_r_2024_01_02/index.html",
    "href": "posts/intro_to_mass_spec_in_r_2024_01_02/index.html",
    "title": "Introduction to Mass Spectrometry Analysis in R",
    "section": "",
    "text": "Mass spectrometry has become an integral analytical technique in natural product discovery, both in measuring accurate mass for chemical formula determination, to analyzing molecule fragmentation for structure elucidation and library searches.\nI won’t go in to too much detail here but there are some important experimental things to consider when approaching the analysis of mass spectrometry data.\nFor more info in the components below see this or similar.\n\n\n\n\nThere are a number of ionizers that are in use in modern mass spectreometers, the most common in outr field being electrospray ionization (ESI). The methods of ionization is important to consider because it will effect which molecules are ionized, how they are ionized, whether the molecules will remain largely intact or fragmented, and what types of adducts you might expect.\n\n\n\nWhen you think of mass spectrometry you think of being able to differentiate molecules of different masses. Anlyzers are what provide the physical separation (or in the case of orbitraps seperation and measurement) of charged molecules within a mass spectreomter. There are a number of analyzers on the market, with the most popular being quadrupoles, ion traps, orbitraps, time-of-flight, and combinations thereof. The type of analyzer is important to consider in the analysis as well, and the following should be thought about when approaching a new analysis.\n\nWhat is the resolving power of the anlyzer(s)?\nOften analyzers will have their efficacy rated in FWHM (full width at half maximum) which is a measure of resolving power\nIf you confuse resolving power with mass resolution you aren’t alone, there’s been much controversy over the years as they somewhat related. See this whitepaper by Agilent. Simply stated, resolving power measures how well you can separate two mass peaks in a spectrum and resolution is a measure of how “wide” your peaks are.\nWhat is the scan speed of your analyzer(s)?\nSome analyzers are veryt fast (ie they can analyze/separate many m/z per second), while others are slower. Some sacrifice sensitivity, accuracy, resolution, etc for higher scan speed. All things to be aware of.\n\n\n\n\nWhile there are different detectors, this isn’t usually a concern during the analysis stage. However, if you notice things like sensitivity is too high or low it could be good feedback to give to the instrument operator as it could be detector settings (though likely sample concentration or ionization efficiency).\nAnother thing to note is that some instruments may have more than one detector and they may serve different purposes. For example, some Time-Of-Flight (TOF) instruments have both a “linear” detector and a “reflectron” detector that elongates the flight path allowing higher resolving power but with a lower m/z ceiling than the “linear” detector."
  },
  {
    "objectID": "posts/intro_to_mass_spec_in_r_2024_01_02/index.html#the-instrument",
    "href": "posts/intro_to_mass_spec_in_r_2024_01_02/index.html#the-instrument",
    "title": "Introduction to Mass Spectrometry Analysis in R",
    "section": "",
    "text": "There are a number of ionizers that are in use in modern mass spectreometers, the most common in outr field being electrospray ionization (ESI). The methods of ionization is important to consider because it will effect which molecules are ionized, how they are ionized, whether the molecules will remain largely intact or fragmented, and what types of adducts you might expect.\n\n\n\nWhen you think of mass spectrometry you think of being able to differentiate molecules of different masses. Anlyzers are what provide the physical separation (or in the case of orbitraps seperation and measurement) of charged molecules within a mass spectreomter. There are a number of analyzers on the market, with the most popular being quadrupoles, ion traps, orbitraps, time-of-flight, and combinations thereof. The type of analyzer is important to consider in the analysis as well, and the following should be thought about when approaching a new analysis.\n\nWhat is the resolving power of the anlyzer(s)?\nOften analyzers will have their efficacy rated in FWHM (full width at half maximum) which is a measure of resolving power\nIf you confuse resolving power with mass resolution you aren’t alone, there’s been much controversy over the years as they somewhat related. See this whitepaper by Agilent. Simply stated, resolving power measures how well you can separate two mass peaks in a spectrum and resolution is a measure of how “wide” your peaks are.\nWhat is the scan speed of your analyzer(s)?\nSome analyzers are veryt fast (ie they can analyze/separate many m/z per second), while others are slower. Some sacrifice sensitivity, accuracy, resolution, etc for higher scan speed. All things to be aware of.\n\n\n\n\nWhile there are different detectors, this isn’t usually a concern during the analysis stage. However, if you notice things like sensitivity is too high or low it could be good feedback to give to the instrument operator as it could be detector settings (though likely sample concentration or ionization efficiency).\nAnother thing to note is that some instruments may have more than one detector and they may serve different purposes. For example, some Time-Of-Flight (TOF) instruments have both a “linear” detector and a “reflectron” detector that elongates the flight path allowing higher resolving power but with a lower m/z ceiling than the “linear” detector."
  },
  {
    "objectID": "posts/intro_to_mass_spec_in_r_2024_01_02/index.html#raw-data-formats",
    "href": "posts/intro_to_mass_spec_in_r_2024_01_02/index.html#raw-data-formats",
    "title": "Introduction to Mass Spectrometry Analysis in R",
    "section": "Raw data formats",
    "text": "Raw data formats\nUnfortunately different instrument vendors, and even different instruments within the same vendor, have their own unique data storage format. This is for a variety of reasons, the most convincing being that instruments have ever increasing speeds of ever-increasing data size and proprietary formats that allow faster/better read/write allow a competitive advantage."
  },
  {
    "objectID": "posts/intro_to_mass_spec_in_r_2024_01_02/index.html#open-source-data-formats",
    "href": "posts/intro_to_mass_spec_in_r_2024_01_02/index.html#open-source-data-formats",
    "title": "Introduction to Mass Spectrometry Analysis in R",
    "section": "Open-source data formats",
    "text": "Open-source data formats\nFortunately there are open standard formats available. You will proabably encounter mzXML and/or its nwer version, mzML; so if you have the option, choose mzML.\nSome vendor software allows converting a file in proprietary data format to mzML, othwise your best bet is likely the program msconvert available as part of the ProteoWizard software library. Unfortunately some vendor formats can only be converted on a Windows computer, a limitation of vendors only providing Windows-based DLLs (so complain your vendor reps about this, not the the ProteoWizard team).\nmsconvert can be used from both a GUI or at the command line\nFor an example of how to use the command line see this zip of a directory that contains a batch file that converts a large number of files at once [https://ccms-ucsd.github.io/GNPSDocumentation/fileconversion/#data-conversion-easy]\nI haven’t had the chance to try them but supposedly there are now some Docker containers that can successfully run msconvert. If you know how badly this was needed then you know how exciting this would be/is.\nI will only cover mzML here as mzXML is similar enough and mzML/mzXML are by far the most commonly encountered in our field. Other formats can be seen at https://www.psidev.info/specifications; and MGF at http://www.matrixscience.com/help/data_file_help.html\n\nmzML\nSo let’s peek at what an mzML file is… As is hinted by the earlier version (mzXML), it is an XML file, which is a highly-structured “markup language”. You can find the current specifications for the standard as well as example files over at https://www.psidev.info/mzml.\nTake a second and look at an example mzml on HUPO-PSI’s GitHub repo.\nThe main things to notice are that it is highly structured.\nFor example:\n&lt;dataProcessing id=\"Xcalibur Processing\" softwareRef=\"Xcalibur\"&gt;\n&lt;processingMethod order=\"1\"&gt;\n&lt;cvParam cvLabel=\"MS\" accession=\"MS:1000033\" name=\"deisotoping\" value=\"false\"/&gt;\n&lt;cvParam cvLabel=\"MS\" accession=\"MS:1000034\" name=\"charge deconvolution\" value=\"false\"/&gt;\n&lt;cvParam cvLabel=\"MS\" accession=\"MS:1000035\" name=\"peak picking\" value=\"true\"/&gt;\n&lt;/processingMethod&gt;\n&lt;/dataProcessing&gt;\n\n&lt;dataProcessing id=\"Xcalibur Processing\" softwareRef=\"Xcalibur\"&gt; opens the “dataProcessing” tag and defines the properties of ‘id’ and ‘softwareRef’; the last line &lt;/dataProcessing&gt; closes the “dataProcessing” tag.\nNested inside within the “dataProcessing” tag is the “processingMethod” tag which opens with &lt;processingMethod order=\"1\"&gt;, and closes with &lt;/processingMethod&gt;.\nThis contains a further nested tag “cvParam” which is different in that it self-closes with a /&gt;.\n\nUsually mzML files are indented which allows you to easily discern which tags are nested under which other tags; but there is no requirement that mzML files have indentations."
  },
  {
    "objectID": "posts/intro_to_mass_spec_in_r_2024_01_02/index.html#whats-a-spectrum",
    "href": "posts/intro_to_mass_spec_in_r_2024_01_02/index.html#whats-a-spectrum",
    "title": "Introduction to Mass Spectrometry Analysis in R",
    "section": "What’s a spectrum?",
    "text": "What’s a spectrum?\nLet’s finally look at some data. We will use some data I acquired previously to make things easier… on me.\nIt’s from an LC-MS/MS run of a single Micromonospora extract, in a previously published study.\n\n\n\n\n\n\nExperimental info\n\n\n\n\n\nThe sample is a Micromonospora extract. The extraction was performed from a bacterial culture growing on solid A1 agar media following the protocol of Bligh,E. G. and Dyer, W. J. (9). Agar cultures were divided into 1 cm3 pieces and 3 mm glass beads were added. Extraction solvent was added in three steps with vigorous vortexing between steps 1) 1:2 (v/v) CHCl3:MeOH, 2) CHCl3 in 1/3 the added volume of step one, 3) H2O in 1/3 the added volume of step one. From the resulting two-layer liquid partition, the organic layer was retained for further analysis.\nThe extract was analyzed via LC-MS/MS with a method adapted from that described by Goering et al. Experiments were performed on an Agilent 1200 workstation connected to a Thermo Fisher Scientific Q-Exactive mass spectrometer with an electrospray ionization source. Reversed-phase chromatography was performed by injection of 20 μL of 0.1 mg/mL of extract at a 0.3 mL/min flow rate across a Phenomenex Kinetex C18 RPLC column (150 mm x 2.1 mm i.d., 2 μm particle size). Mobile phase A was water with 0.1% formic acid and mobile phase B was acetonitrile with 0.1% formic acid. Mobile phase B was held at 15% for 1 minute, then adjusted to 95% over 12 minutes, where it was held for 2 minutes, and the system re-equilibrated for 5 minutes. The mass spectrometry parameters were as follows: scan range 200-2000 m/z, resolution 35,000, scan rate ~3.7 per second. Data were gathered in profile and the top 5 most intense peaks in each full spectrum were targeted for fragmentation that employed a collision energy setting of 25 eV for Higher-energy Collisional Dissociation (HCD) and isolation window of 2.0 m/z.\nThe mzXML file was created with ProteoWizard’s msconvert, using default settings.\n\n\n\n\nSetup R session\nInstall and then load mzR, a Bioconductor package for parsing mass spectrometry data. Vignette here. For plotting I’ll use ggplot2.\n\nif (!require(\"mzR\", quietly = TRUE))\n    install.packages(\"mzR\")\nif (!require(\"ggplot2\", quietly = TRUE))\n    install.packages(\"ggplot2\")\n  \nlibrary(mzR)\nlibrary(ggplot2)\n\n\n\nDownload example data\nNext I’ll download the example file to a temporary directory (will be deleted upon closing the R session). Warning: This is a 22 MB and 306 MB download.\n\ntemporary_directory &lt;- tempdir()\npeaks_file_path &lt;- file.path(temporary_directory, \"B022.mzXML\" )\ndownload.file(url = \"ftp://massive.ucsd.edu/v01/MSV000081555/peak/B022.mzXML\",\n              destfile = peaks_file_path)\n\nraw_mzml_path &lt;- file.path(temporary_directory, \"B022.mzML\" )\ndownload.file(url = \"ftp://massive.ucsd.edu/v01/MSV000081555/raw/FullSpectra-mzML/B022_GenbankAccession-KY858245.mzML\",\n              destfile = raw_mzml_path)\n\n\n\nPeek around\n\nfull_spectra_handle &lt;- mzR::openMSfile(raw_mzml_path)\n\n\nheader(full_spectra_handle)[2243, ]\n\n\n  \n\n\n\n\nheader(full_spectra_handle)[2243, ]$precursorMZ\n\n[1] 743.5622\n\n\n\n\nReanalysis of strain B022, MS scan 2242 & 2243, C14 acyl-desferrioxamine\n2242 is the MS1 scan that contains the precursor for the MS2 scan “2243” which appeared in Figure S6F.\n\nsingle_spectrum &lt;- mzR::peaks(full_spectra_handle, scans=2242)\nsingle_spectrum &lt;- as.data.frame(single_spectrum)\ncolnames(single_spectrum) &lt;- c(\"mass\", \"intensity\")\n\n\nnrow(single_spectrum)\n\n[1] 7076\n\n\n\nplot(\n  single_spectrum,\n  type = \"l\",\n)\n\n\n\n\n\n\n\n\nLet’s zoom in on the 13C isotopic envelope of the “743.5622 m/z” precursor.\n\nggplot(\n  data = subset(single_spectrum, mass &gt; 743 & mass &lt; 750),\n  aes(\n    x = mass, \n    y = intensity\n  )\n) + \n  geom_line(color=\"gray48\") + \n  geom_point(size = 0.75, color=\"gray0\")\n\n\n\n\n\n\n\n\nAnd zoom in further to the M+H ion.\n\nggplot(\n  data = subset(single_spectrum, mass &gt; 743 & mass &lt; 744),\n  aes(\n    x = mass, \n    y = intensity\n  )\n) + \n  geom_line(color=\"gray48\") + \n  geom_point(size = 0.75, color=\"gray0\") \n\n\n\n\n\n\n\n\nAn important thing to take note of when doing most types of spectroscopy/spectrometry is the number of measurements across a peak. Here we are getting ~10 data points per ion/peak which is pretty good. The smaller the number of points, the worse your peak shape will be, the worse your accuracy and precision will be. Alternately, too many points can bloat your data size and sometimes make analyses more difficult. This is largely controlled by dwell time and duty cycles in the MS acquisition settings. Instrument settings/chromatography may have to be optimized to balance sensitivity with getting enough data points.\n\nggplot(\n  data = subset(single_spectrum, mass &gt; 743 & mass &lt; 744),\n  aes(\n    x = mass, \n    y = intensity\n  )\n) + \n  geom_line(color=\"gray48\") + \n  geom_point(size = 0.75, color=\"gray0\") +\n  geom_point(data = subset(subset(single_spectrum, mass &gt; 743 & mass &lt; 744), intensity &gt; 100),aes(\n    x = mass, \n    y = intensity\n  ),  size = 3, color=\"red\") \n\n\n\n\n\n\n\n\nLet’s create a extracted ion chromatogram (EIC) for the “743.5622 m/z” precursor.\nTo do that we need to loop through all the MS1 spectra\n\nfull_spectra_header &lt;- header(full_spectra_handle)\nms1_indices &lt;- full_spectra_header[full_spectra_header$msLevel == 1, ]$seqNum\n\ntarget_mass &lt;- 743.5646\ndelta &lt;- 0.01\n\nleft_window &lt;- target_mass - delta\nright_window &lt;- target_mass + delta\n\nz &lt;- lapply(ms1_indices, \n  function(x){\n    ret_time &lt;- full_spectra_header[x, ]$retentionTime\n    x &lt;- mzR::spectra(full_spectra_handle, x)\n    x &lt;- as.data.frame(x)\n    colnames(x) &lt;- c(\"mass\", \"intensity\")\n    x &lt;- x[x$mass &gt; left_window & x$mass &lt; right_window,  ]\n    if (nrow(x) &gt; 0){\n      return(data.frame(list(ret_time=ret_time, intensity=mean(x$intensity))))\n    } else {\n      return(data.frame(list(ret_time=ret_time, intensity=0)))\n    }\n  }\n)\nz2 &lt;- do.call(\"rbind\", z)\n\nCorresponds to Figure S5E:\n\ntitle = paste(\n  \"Extracted Ion Chromatogram: \",\n  target_mass,\n  \" \",\n  expression(italic(\"m/z\")),\n  \" +/- \",\n  delta,\n   \" Da\")\n\nggplot(\n  data = z2,\n  aes(\n    x = ret_time / 60,\n    y = intensity\n  )\n) + \n  geom_line(color=\"gray48\") +\n  xlab(\"Retention Time (min)\") +\n      ggtitle(bquote(\"Extracted Ion Chromatogram:\"~.(target_mass) ~italic(\"m/z\")~\"+/-\"~.(delta) ~\"Da\"))\n\n\n\n\n\n\n\n\nLet’s highlight where the instrument fragmented parent ions between 743 m/z & 745 m/z?\n\nggplot(\n  data = z2,\n  aes(\n    x = ret_time / 60,\n    y = intensity\n  )\n) + \n  geom_line(color=\"gray48\") + \n  geom_point(\n    data = subset(full_spectra_header, precursorMZ &gt; 743 & precursorMZ &lt; 745),\n    aes(x=retentionTime / 60, y= 5e5),\n    color=\"red\"\n    ) +\n  xlab(\"Retention Time (min)\")\n\n\n\n\n\n\n\n\nAnother consideration for the experimentalist (and good exam question 😛 ) is how you could obtain more scans of this 743.5622 m/z target ion. There’s multiple ways (the most obvious is to run in targeted mode where you only fragment parent molecules within a tight range around 743.5622 m/z), but if you need untargetted mode you can mess with duty cycles, or adjust your chromatography to increase the elution peak width of the target compound; sometimes 5min chromatography isn’t the best chromatography.\nAnd we can see it is indeed an mzXML file.\n\ncat(readLines(peaks_file_path, n=10), sep = \"\\n\")\n\n&lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?&gt;\n&lt;mzXML xmlns=\"http://sashimi.sourceforge.net/schema_revision/mzXML_3.2\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://sashimi.sourceforge.net/schema_revision/mzXML_3.2 http://sashimi.sourceforge.net/schema_revision/mzXML_3.2/mzXML_idx_3.2.xsd\"&gt;\n  &lt;msRun scanCount=\"4399\" startTime=\"PT0.0673789S\" endTime=\"PT1200.11S\"&gt;\n    &lt;parentFile fileName=\"file:///C:\\Users\\chase\\Downloads\\LCMSNORTHWESTERN\\Example\\Input_Folder/20170719_mwm1013_metabologenomics_actinolunaC182x100_B022.raw\"\n                fileType=\"RAWData\"\n                fileSha1=\"b739a75b1c680e889940f7b35fe9ef07ee5bcd62\"/&gt;\n    &lt;msInstrument msInstrumentID=\"1\"&gt;\n      &lt;msManufacturer category=\"msManufacturer\" value=\"Thermo Scientific\"/&gt;\n\n\nI really like mzR. Under the hood is a lot of fast C/C++ code, and it is possible to lazily load the data from mzML files.\nHere we will tell mzR to lazily open the mass spec file we just downloaded. We can see it returns a handle to the file, which contains 4399 “scans”. A scan being a mass spectrum.\n\nmsfile_handle &lt;- mzR::openMSfile(peaks_file_path)\nmsfile_handle\n\nMass Spectrometry file handle.\nFilename:  B022.mzXML \nNumber of scans:  4399 \n\n\nmzR uses S3 object oriented programming which is difficult if you are only used to R’s usual functional programming style. You don’t have to worry much about it because most of what I’ll show is functional, but if you do care there are a number of object based methods you can use.\nWe can see how mzR “opened/parsed” the file, here using C++ code from ProteoWizard.\n\nmsfile_handle@backend\n\nC++ object &lt;0x55f35cb5f5d0&gt; of class 'Pwiz' &lt;0x55f35ac20450&gt;\n\n\nThese are the methods available to be run on files parsed with the Pwiz object (not all will be applicable to all types of MS data).\n\nmzR:::Pwiz\n\nC++ class 'Pwiz' &lt;0x55f35ac20450&gt;\nConstructors:\n    Pwiz()\n        docstring : Initialises a new Rccp pwiz object.\n\nFields: No public fields exposed by this class\n\nMethods: \n     void close()  \n           docstring : Close the connection to a mass spec file (mzXML, mzData, etc.).\n     void copyWriteMSfile(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, Rcpp::DataFrame_Impl&lt;Rcpp::PreserveStorage&gt;, Rcpp::List, bool, Rcpp::List)  \n           docstring : Copy general content from the originalting MS file, add the provided spectrum list and write the data to a new mzML file.\n     Rcpp::Matrix&lt;14, Rcpp::PreserveStorage&gt; get3DMap(std::vector&lt;int, std::allocator&lt;int&gt; &gt;, double, double, double)  \n           docstring : Reads all scans and returns them as a matrix.\n     Rcpp::DataFrame_Impl&lt;Rcpp::PreserveStorage&gt; getAllChromatogramHeaderInfo()  \n           docstring : Returns a data.frame with the header for all chromatograms\n     Rcpp::DataFrame_Impl&lt;Rcpp::PreserveStorage&gt; getAllScanHeaderInfo()  \n           docstring : Reads the header info for all mass spectra.\n     Rcpp::DataFrame_Impl&lt;Rcpp::PreserveStorage&gt; getChromatogramHeaderInfo(Rcpp::IntegerVector)  \n           docstring : Returns a data.frame with the chromatogram header information\n     Rcpp::DataFrame_Impl&lt;Rcpp::PreserveStorage&gt; getChromatogramsInfo(int)  \n           docstring : Reads the chromatogram information.\n     std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; getFilename()  \n           docstring : Returns the mass spec filename.\n     Rcpp::List getInstrumentInfo()  \n           docstring : Reads the instrument information from a pwiz object\n     int getLastChrom()  const \n           docstring : Returns the index of the last chromatogram.\n     int getLastScan()  const \n           docstring : Returns the last scan (not necessarily the number of scans because of missing scans).\n     Rcpp::List getPeakList(Rcpp::IntegerVector)  \n           docstring : Performs a non-sequential parsing operation on an indexed mzXML file to obtain the peak list for a numbered scan.\n     std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; getRunStartTimeStamp()  \n           docstring : Returns the start time stamp of the MS run.\n     Rcpp::DataFrame_Impl&lt;Rcpp::PreserveStorage&gt; getScanHeaderInfo(Rcpp::IntegerVector)  \n           docstring : Reads the header info for the specified scan(s). Supports also to extract scan header infos for multiple scans.\n     void open(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;)  \n           docstring : Opens a mass spec file (mzXML, mzData, etc.) and creates a pwiz object\n     void writeSpectrumList(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, Rcpp::DataFrame_Impl&lt;Rcpp::PreserveStorage&gt;, Rcpp::List, bool, Rcpp::List)  \n           docstring : Write the spectrum list to an mzML file.\n\n\nOne of the most powerful {{mzR}} functions is header() which provides summarizing information about each scan in the dataset. Each scan is numbered sequentially (seqNum/acquisitionNum) and the msLevel (MS == 1; MS2 == 2, MS3 == 3, etc.)\n\nsummary_data &lt;- header(msfile_handle)\nhead(summary_data)\n\n\n  \n\n\n\nSo, now we can do things like filtering for only positive mode MS2 scans.\n\nfiltered_df &lt;- summary_data[summary_data$polarity == 1, ][summary_data$msLevel == 2, ]\nhead(filtered_df)\n\n\n  \n\n\n\nThe next useful function retrieves the actual mass spectra. It will load every scan in the file as a two-column separate matrix. For each matrix the first column represents m/z and the second column is intensity.\nLet’s look at the first five lines of the twenty-second scan/mass spectrum.\n\n# note: mzR::peaks() and mzR::spectra() are interchangeable\nsingle_spectrum &lt;- mzR::peaks(msfile_handle, scans=4)\nhead(single_spectrum, 5)\n\n         [,1]      [,2]\n[1,] 150.0265 32913.336\n[2,] 151.0238  2110.815\n[3,] 151.0272  3636.793\n[4,] 152.0564  4872.385\n[5,] 153.0907  2387.040\n\n\nWe can load just the filtered MS2\n\npositive_ms2_header &lt;- summary_data[summary_data$polarity == 1, ][summary_data$msLevel == 2, ]\npositive_ms2_scan_index &lt;- positive_ms2_header$seqNum\npositive_ms2_spectra &lt;- mzR::peaks(msfile_handle, positive_ms2_scan_index)\n\nCheck that we only grabbed the positive, MS2 spectra\n\nlength(positive_ms2_spectra) == nrow(positive_ms2_header)\n\n[1] TRUE\n\n\n\nselected_scan &lt;- 2243\nspectrum_to_plot &lt;- mzR::peaks(msfile_handle, selected_scan)\nspectrum_df &lt;- as.data.frame(spectrum_to_plot)\ncolnames(spectrum_df) &lt;- c(\"m/z\", \"intensity\")\n\nLet’s write a couple helper functions first.\n\n# Fancy_scientific creates scientific notation text\nfancy_scientific &lt;- function(l) {\n  # \"fancy_scientific\" was copied from comment from Brian Diggs posted at https://groups.google.com/forum/#!topic/ggplot2/a_xhMoQyxZ4\n  # turn in to character string in scientific notation\n  l &lt;- format(l, scientific = TRUE)\n  # quote the part before the exponent to keep all the digits\n  l &lt;- gsub(\"^(.*)e\", \"'\\\\1'e\", l)\n  # turn the 'e+' into plotmath format\n  l &lt;- gsub(\"e\", \"%*%10^\", l)\n  # return this as an expression\n  parse(text=l)\n}\n\n# gets top N intensity peaks\ntopn &lt;- function(x, n=10) { x[order(x[, 2], decreasing = ifelse(all(x[, 2] &lt; 0), F, T))[1:n], ] }\n\n\nplot_peaks &lt;- function(df1, plot_title){\n  ggplot() +\n  geom_bar(data = df1, aes(x = `m/z`, y = `intensity`), stat = \"identity\", width = 1) +\n  geom_text(data=topn(df1), aes(x = `m/z`, y = `intensity` * 1.05, label = as.numeric(sprintf('%.4f', `m/z`))), size = 3) +\n  scale_y_continuous(name=\"Intensity\", labels = fancy_scientific) +\n  xlab(label = expression(italic(\"m/z\"))) +\n  ggtitle(plot_title) +\n  theme(plot.title = element_text(hjust = 0.5))\n}\n\nplot_mirror &lt;- function(df1, df2, plot_title, df1_name, df2_name){\n  df1$`intensity` &lt;- df1$`intensity` / max(df1$`intensity`) * 100 \n  df2$`intensity` &lt;- df2$`intensity` / max(df2$`intensity`) * 100 * -1\n  \n  df3 &lt;- rbind.data.frame(\n    cbind.data.frame(df1, spectrum=df1_name),\n    cbind.data.frame(df2, spectrum=df2_name)\n  )\n  # ensure the input spectrum (positive spectrum) appears as the top label in the legend\n  df3$spectrum &lt;- factor(df3$spectrum, levels=c(df1_name, df2_name))\n  \n  ggplot() +\n    geom_bar(data = df3, aes(x = `m/z`, y = `intensity`, fill=`spectrum`), stat = \"identity\", width = 2) +\n    scale_fill_manual(\"legend\", values = c( \"blue\",  \"red\")) +\n    # write the m/z labels to 4 decimal places\n    geom_text(data=topn(df1), aes(x = `m/z`, y = `intensity` * 1.05, label = as.numeric(sprintf('%.4f', `m/z`))), size = 3) +\n    geom_text(data=topn(df2), aes(x = `m/z`, y = `intensity` * 1.05, label = as.numeric(sprintf('%.4f', `m/z`))), size = 3) +\n    scale_y_continuous(name=\"Intensity\", labels = fancy_scientific) +\n    xlab(label = expression(italic(\"m/z\"))) +\n    ggtitle(plot_title) +\n    theme(plot.title = element_text(hjust = 0.5))\n}\n\n\ninput_file_name &lt;- basename(mzR::fileName(msfile_handle))\nplot_title &lt;- paste0(\"File: \", input_file_name, \"; scan: \", selected_scan)\n\nplot_peaks(spectrum_df, plot_title)\n\nWarning: `position_stack()` requires non-overlapping x intervals\n\n\n\n\n\n\n\n\n\n\ngnps_spectrum_df &lt;- read.delim(\"/home/chase/Downloads/CCMSLIB00000072054.mgf\", sep=\"\\t\", skip = 3, header=FALSE, nrows = 500)\ngnps_spectrum_df &lt;- as.data.frame(gnps_spectrum_df)\ncolnames(gnps_spectrum_df) &lt;- c(\"m/z\", \"intensity\")\n\nplot_title &lt;- \"GNPS Library: CCMSLIB00000072054\"\n\nplot_peaks(gnps_spectrum_df, plot_title)\n\nWarning: `position_stack()` requires non-overlapping x intervals\n\n\n\n\n\n\n\n\n\n\nplot_mirror(\n  df1 = spectrum_df,\n  df2 = gnps_spectrum_df,\n  df1_name = \"input\",\n  df2_name = \"CCMSLIB00000072054\",\n  plot_title = \"Comparison to GNPS Reference\")\n\nWarning: `position_stack()` requires non-overlapping x intervals\n`position_stack()` requires non-overlapping x intervals"
  },
  {
    "objectID": "contributors/joe/joe.html",
    "href": "contributors/joe/joe.html",
    "title": "Joe",
    "section": "",
    "text": "This blog was started by two pharmacosisgnosist who realized that our field requires a diverse set of in-demand informatics skills but that there are limited University programs offering detailed instruction on code-based analysis of the wide array of analytical techniques we encounter every dat. Here we hope to share some of our own experience in using code to analyze the chemical and biological data a pharmacognosist is ikely to encounter in the modern era.\n(image created with DALL·E 3)",
    "crumbs": [
      "Joe"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Computational Pharmacognosy",
    "section": "",
    "text": "Introduction to Mass Spectrometry Analysis in R\n\n\n\n\n\n\n\n\nFirst in a series of posts about what mass spectrometry data looks like, using R\n\n\n\n\n\nJan 2, 2024\n\n\nChase M Clark\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction to Mass Spectrometry Analysis in R\n\n\n\n\n\n\n\n\nIntroduction to cheminformatics\n\n\n\n\n\nJan 2, 2024\n\n\nChase M Clark\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction to reproducible computing\n\n\n\n\n\n\n\n\nIntroduction to reproducible computing\n\n\n\n\n\nJan 2, 2024\n\n\nChase M Clark\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction to reproducible computing: Docker\n\n\n\n\n\n\n\n\nIntroduction to reproducible computing; Docker\n\n\n\n\n\nJan 2, 2024\n\n\nChase M Clark\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "contributors/chase/chase.html#summary",
    "href": "contributors/chase/chase.html#summary",
    "title": "Chase",
    "section": "Summary",
    "text": "Summary\nChase is a Postdoctoral Research Associate at the University of Wisconsin-Madison where he was awarded and partially funded by a T32 Fellowship in the Computation and Informatics in Biology and Medicine (CIBM) training program. Chase completed a PhD in Pharmacognosy with Dr. Brian Murphy at the University of Illinois at Chicago where he was awarded and funded by NIH F31 fellowship\nChase has &gt;10 years of lab and computational experience surrounding natural products. Non-comprehensively, this spans analytical chemistry/biochemistry/microbiology method development and R&D at a small enzyme and probiotic manufacturer, to mass spectrometry method and software development in grad school, to engineering large scale genome mining and metagneomic software for drug discovery.\nChase would like to spend more time outdoors this year– kayaking, scuba diving, cycling, etc.\nMore info can be found at https://chasemc.github.io.",
    "crumbs": [
      "Chase"
    ]
  },
  {
    "objectID": "contributors/chase/chase.html#education",
    "href": "contributors/chase/chase.html#education",
    "title": "Chase",
    "section": "Education",
    "text": "Education\nUniversity of Illinois at Chicago | Chicago, IL | PhD in Pharmacognosy | 2015 - 2020\nBerry College | Mount Berry, GA | B.S. in Biochemisty | 2008 - 2012",
    "crumbs": [
      "Chase"
    ]
  },
  {
    "objectID": "contributors/chase/chase.html#experience",
    "href": "contributors/chase/chase.html#experience",
    "title": "Chase",
    "section": "Experience",
    "text": "Experience\nUniversity of Wisconsin-Madison | Postdoctoral Fellow/Associate (Computational Biology, Data Science, Drug Discovery) | 2020 - present\nDeerland Probiotics & Enzymes | R&D Tech | 2013 - 2015\n(image created with DALL·E 3)\n\nPublications\n\n\n(1) Mullowney, M. W.; Duncan, K. R.; Elsayed, S. S.; Garg, N.; Hooft, J. J. J. van der; Martin, N. I.; Meijer, D.; Terlouw, B. R.; Biermann, F.; Blin, K.; Durairaj, J.; Gorostiola González, M.; Helfrich, E. J. N.; Huber, F.; Leopold-Messer, S.; Rajan, K.; Rond, T. de; Santen, J. A. van; Sorokina, M.; Balunas, M. J.; Beniddir, M. A.; Bergeijk, D. A. van; Carroll, L. M.; Clark, C. M.; Clevert, D.-A.; Dejong, C. A.; Du, C.; Ferrinho, S.; Grisoni, F.; Hofstetter, A.; Jespers, W.; Kalinina, O. V.; Kautsar, S. A.; Kim, H.; Leao, T. F.; Masschelein, J.; Rees, E. R.; Reher, R.; Reker, D.; Schwaller, P.; Segler, M.; Skinnider, M. A.; Walker, A. S.; Willighagen, E. L.; Zdrazil, B.; Ziemert, N.; Goss, R. J. M.; Guyomard, P.; Volkamer, A.; Gerwick, W. H.; Kim, H. U.; Müller, R.; Wezel, G. P. van; Westen, G. J. P. van; Hirsch, A. K. H.; Linington, R. G.; Robinson, S. L.; Medema, M. H. Artificial Intelligence for Natural Product Drug Discovery. Nat. Rev. Drug Discov. 2023, 22 (11), 895–916. https://doi.org/10.1038/s41573-023-00774-7.\n\n\n(2) Rees, E. R.; Uppal, S.; Clark, C. M.; Lail, A. J.; Waterworth, S. C.; Roesemann, S. D.; Wolf, K. A.; Kwan, J. C. Autometa 2: A Versatile Tool for Recovering Genomes from Highly-Complex Metagenomic Communities. bioRxiv, 2023, 2023.09.01.555939. https://doi.org/10.1101/2023.09.01.555939.\n\n\n(3) Waterworth, S. C.; Rees, E. R.; Clark, C. M.; Carlson, S.; Miller, I. J.; Puglisi, M.; Kwan, J. C. Elevated Expression of Srp RiPPs Across Bacterial Phyla in Marine Sponges. bioRxiv, 2023, 2023.06.09.544420. https://doi.org/10.1101/2023.06.09.544420.\n\n\n(4) Clark, C. M.; Nguyen, L.; Pham, V. C.; Sanchez, L. M.; Murphy, B. T. Automated Microbial Library Generation Using the Bioinformatics Platform IDBac. Molecules 2022, 27 (7). https://doi.org/10.3390/molecules27072038.\n\n\n(5) Clark, C. M.; Hernandez, A.; Mullowney, M. W.; Fitz-Henley, J.; Li, E.; Romanowski, S. B.; Pronzato, R.; Manconi, R.; Sanchez, L. M.; Murphy, B. T. Relationship Between Bacterial Phylotype and Specialized Metabolite Production in the Culturable Microbiome of Two Freshwater Sponges. ISME Communications 2022, 2 (1), 1–8. https://doi.org/10.1038/s43705-022-00105-8.\n\n\n(6) Elfeki, M.; Mantri, S.; Clark, C. M.; Green, S. J.; Ziemert, N.; Murphy, B. T. Evaluating the Distribution of Bacterial Natural Product Biosynthetic Genes Across Lake Huron Sediment. ACS Chem. Biol. 2021, 16 (11), 2623–2631. https://doi.org/10.1021/acschembio.1c00653.\n\n\n(7) Leao, T. F.; Clark, C. M.; Bauermeister, A.; Elijah, E. O.; Gentry, E. C.; Husband, M.; Oliveira, M. F.; Bandeira, N.; Wang, M.; Dorrestein, P. C. Quick-Start Infrastructure for Untargeted Metabolomics Analysis in GNPS. Nat Metab 2021, 3 (7), 880–882. https://doi.org/10.1038/s42255-021-00429-0.\n\n\n(8) Clark, C. M.; Murphy, B. T.; Sanchez, L. M. A Call to Action: The Need for Standardization in Developing Open-Source Mass Spectrometry-Based Methods for Microbial Subspecies Discrimination. mSystems 2020, 5 (1). https://doi.org/10.1128/mSystems.00813-19.\n\n\n(9) Costa, M. S.; Clark, C. M.; Ómarsdóttir, S.; Sanchez, L. M.; Murphy, B. T. Minimizing Taxonomic and Natural Product Redundancy in Microbial Libraries Using MALDI-TOF MS and the Bioinformatics Pipeline IDBac. J. Nat. Prod. 2019, 82 (8), 2167–2173. https://doi.org/10.1021/acs.jnatprod.9b00168.\n\n\n(10) Clark, C. M.; Costa, M. S.; Conley, E.; Li, E.; Sanchez, L. M.; Murphy, B. T. Using the Open-Source MALDI TOF-MS IDBac Pipeline for Analysis of Microbial Protein and Specialized Metabolite Data. J. Vis. Exp. 2019, No. 147. https://doi.org/10.3791/59219.\n\n\n(11) Braesel, J.; Clark, C. M.; Kunstman, K. J.; Green, S. J.; Maienschein-Cline, M.; Murphy, B. T.; Eustáquio, A. S. Genome Sequence of Marine-Derived Streptomyces Sp. Strain F001, a Producer of Akashin a and Diazaquinomycins. Microbiol Resour Announc 2019, 8 (19). https://doi.org/10.1128/MRA.00165-19.\n\n\n(12) Clark, C. M.; Costa, M. S.; Sanchez, L. M.; Murphy, B. T. Coupling MALDI-TOF Mass Spectrometry Protein and Specialized Metabolite Analyses to Rapidly Discriminate Bacterial Function. Proceedings of the National Academy of Sciences, 2018, 115, 4981–4986. https://doi.org/10.1073/pnas.1801247115.",
    "crumbs": [
      "Chase"
    ]
  },
  {
    "objectID": "about/about.html",
    "href": "about/about.html",
    "title": "About",
    "section": "",
    "text": "This blog was started by two pharmacosisgnosist who realized that our field requires a diverse set of in-demand informatics skills but that there are limited University programs offering detailed instruction on code-based analysis of the wide array of analytical techniques we encounter every dat. Here we hope to share some of our own experience in using code to analyze the chemical and biological data a pharmacognosist is ikely to encounter in the modern era.\n(image created with DALL·E 3)"
  },
  {
    "objectID": "posts/series_reproducibility/docker/index.html",
    "href": "posts/series_reproducibility/docker/index.html",
    "title": "Introduction to reproducible computing: Docker",
    "section": "",
    "text": "Docker Logo"
  }
]